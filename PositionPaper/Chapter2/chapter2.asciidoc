= Capitolo 2: Blockchain e Bitcoin: cosa sono e quali sono gli elementi che li definiscono

== Funzioni di Hash e strutture dati Blockchain

Per prevenire fenomeni di contraffazione in un sitema di pagamenti peer-to-peer non controllato da un'istituzione fiduciaria centrale è necessario ricorrere ad alcuni strumenti di crittografia quali ad esempio funzioni e puntatori di hash.

Una *funzione di hash* è un algoritmo non invertibile che trasforma un qualsiasi insieme di dati in formato digitale _x_, in una stringa _H(x)_ (*hash value*) di dimensione fissa _n_ bit, indipendentemente dalla dimensione dell'input.

Dato _n_, le possibili combinazioni di _n_ bit (possibili output) sono finite: _2^n^_ possibili combinazioni poichè ogni bit può assumere due valori, 0 oppure 1. Pertanto diversi input possono dare origine allo stesso hash value (si parla di _collisione_).

Una funzione di hash "_crittograficamente sicura_" deve garantire tre proprietà:

1. pass:[<u>Collision resistance</u>];
2. pass:[<u>Hiding</u>];
3. pass:[<u>Puzzle friendliness</u>].

Se le collisioni esistono, la prima proprietà garantisce almeno che sia praticamente impossibile trovarne una: dati due input _x_, _y_ tali che _H(x) = H(y)_, allora quasi certamente _x = y_, o meglio è altamente improbabile che _x_ sia diverso da _y_. Prendendo ad esempio le due funzioni di hash usate nel protocollo Bitcoin, _SHA256_ (_n = 256_ bit) e _RIPEMD160_ (_n = 160_ bit), per avere la certezza di trovare due numeri che generino lo stesso hash value è necessario provare almeno tanti valori quanti sono i possibili output, _2^256^_ (circa _10^77^_) tentativi per SHA256 e _2^160^_ (circa _10^48^_) tentativi per RIPEMD160 (numeri estremamente grandi se si pensa che il primo è dell'ordine di grandezza degli atomi stimati nell'universo visibile).

L'hash value può dunque essere considerato a tutti gli effetti come "l'impronta digitale" dei dati di input. Due input che generano lo stesso hash value rappresentano quasi certamente lo stesso dato di input. Una comune applicazione consiste nel memorizzare l'hash value di un certo insieme di dati (ad esempio un file generico) ed utilizzarlo in un secondo momento per certificare che questi non hanno subito alterazioni (modifiche dei dati comportano un differente output).

La seconda proprietà (_hiding_) sintetizza come a partire dall'hash value di un input sconosciuto, sotto certe ipotesi, sia praticamente impossibile risalire all'input stesso. Una funzione di hash è infatti non invertibile e per ottenere il dato di partenza non esiste una procedura più rapida rispetto a calcolare l'hash value di tutti i possibili input fino a trovare quello cercato. Se l'insieme di partenza è estremamente ristretto questa procedura è piuttosto semplice e veloce. Per questo motivo spesso la proprietà di hiding viene espressa come segue: dato _H(x|r)_ (_x_ concatenato _r_), se _r_ è un numero casuale sconosciuto estratto da un insieme particolarmente ampio e ben distribuito (si parla di distribuzione ad alta entropia minima), risulta impossibile risalire ad _x_.

L'applicazione principale di questa proprietà è il _commitment_ digitale. La procedura di commitment consiste nel nascondere un messaggio _x_ concatenato con un numero casuale _r_ all'interno di una scatola nera, ovvero l'hash value _H(x|r)_. L'emittente del messaggio rende dunque pubblico l'hash value, ma non il messaggio stesso nè la chiave _r_. In un qualsiasi momento l'autore può rivelare il messaggio celato e dimostrarne l'autenticità rendendo nota la chiave. Noti _x_ ed _r_ chiunque può calcolare _H(x|r)_ e verificare che corrisponda all'hash value pubblicato.

La terza ed ultima proprietà afferma che dato un certo output casuale _y_ e un valore _k_ estratto da una distribuzione ad alta entropia minima (vedi sopra), allora è impossibile trovare un _x_ tale che _H(k|x) = y_. La differenza rispetto all'enunciato della proprietà di hiding è che in questo caso _y_ non è scelto come hash value di un particolare insieme di dati, ma piuttosto come target che vogliamo raggiungere senza alcuna limitazione nella scelta del valore di input _x_. Ancora una volta l'unico modo di procedere è per tentativi e il numero minimo di tentativi per avere la certezza di replicare _y_ è _2^n^_.

Quest'utlima proprietà è alla base del gioco matematico con cui, si vedrà, vengono validati i blocchi di transazioni all'interno della BlockChain. Tale gioco noto come _puzzle di ricerca_ consiste nel trovare un valore _x_ (detto _nounce_) tale che dato un insieme limitato di output _Y_ e un numero casuale _k_ scelto come sopra, allora _H(k|x) ∈ Y_, ovvero l'hash value di _k_ concatenato con _x_ è nell'insieme target _Y_.

Un *hash pointer* è un puntatore alla zona di memoria in cui è localizzato un certo insieme di dati. A differenza di un semplice puntatore l'hash pointer contiene anche l'hash value dei dati, consentendo di verificare in ogni istante che questi non abbiano subito modifiche.

Una struttura di dati memorizzati in blocchi concatenati tra loro attraverso dei puntatori di hash viene detta *blockchain* (da qui il celebre nome utilizzato per il registro pubblico delle transazioni in bitocoin). Ogni blocco, oltre ai dati memorizzati al suo interno, contiene anche “l’impronta digitale” del blocco puntato, di modo che l'alterazione del contenuto di uno qualsiasi dei blocchi della catena provoca una modifica in tutti i blocchi ad esso collegati. L'hash value dell'ultimo puntatore della catena è sufficiente come codifica di tutta la catena.

Un’altra struttura molto utilizzata in crittografia è il *Merkle tree*, un albero binomiale costruito attraverso puntatori di hash. Un certo numero di blocchi di dati costituiscono le foglie dell’albero. Queste vengono raggruppate a coppie e per ciascuna coppia viene creato un nodo superiore con due hash pointer, ciascuno dei quali punta ad un elemento della coppia. La stessa procedura viene ripetuta per il nuovo insieme di nodi. Ad ogni iterazione il numero di nodi appartenenti al livello superiore si dimezza fino a che si arriva ad avere un singolo nodo, la radice dell’albero o *Merkle root*. L'hash value del Merkle root è la sintesi dell'infomazione presente in tutto l'albero; la modifica di una singola foglia infatti si traduce in un diverso hash value della radice grazie alla struttura di puntatori. Le transazioni in bitcoin all'interno dei blocchi del registro pubblico vengono memorizzate attraverso alberi binomiali di Merkle.

== Chiave Pubblica, Chiave Privata e Firma Digitale

In una rete di pagamenti digitale, come quella di Bitcoin, la crittografia asimmetrica è lo strumento più efficace per garantire che solo il destinatario di una transazione abbia accesso ai fondi a lui destinati. Ogni individuo/nodo della rete può creare una o più coppie di chiavi pubblica-privata. La chiave pubblica viene utilizzata per generare l'indirizzo a cui verrà destinata la transazione. La chiave privata rappresenta invece il codice con il quale il destinatario può sbloccare e riutilizzare i fondi della transazione. Più semplicemente la chiave pubblica viene utilizzata per ricevere fondi e può essere paragonata al numero di un conto in banca; la chiave privata serve per firmare le transazioni e spendere i fondi rappresentando l’analogo del PIN che permette di controllare il conto.

I meccanismi di generazione di coppie di chiavi pubblica-privata si basano su nozioni di algebra modulare e curve ellittiche. La chiave privata consiste in un numero particolarmente elevato che deve essere assolutamente calcolato in maniera *casuale*. A partire da esso, utilizzando una funzione crittografica non invertibile, ovvero la moltiplicazione su curve ellittiche, viene generata la chiave pubblica. Da quest’ultima, utilizzando un’altra funzione crittografica non invertibile, una funzione di hash, viene generato un indirizzo bitcoin. La conoscenza di una chiave privata è alla base del controllo su tutti i fondi associati al corrispondente indirizzo, per tale ragione deve essere calcolata in maniera del tutto random e mantenuta segreta senza il rischio di perderla. La chiave privata è utilizzata per la creazione delle firme necessarie per dimostrare la proprietà dei bitcoin che si vuole spendere.
Il motivo per cui viene utilizzata la crittografia asimmetrica (chiave pubblica/privata) risiede nel fatto che rende possibile per ciascuno verificare la firma su ogni transazione, garantendo che solo chi possiede le chiavi private possa fornire delle firme valide.

Come già accennato, il punto fondamentale nella creazione delle chiavi è trovare una fonte sicura di entropia o casualità; di fatto creare una chiave privata equivale essenzialmente a prendere un numero tra 1 e 2^256^, pertanto il modo in assoluto più sicuro di farlo sarebbe quello di tirare una moneta 256 volte, ottenendo la rappresentazione binaria della chiave stessa. La dimensione dello spazio delle chiavi private bitcoin, 2^256^, è un numero incredibilmente grande, circa 10^77^ in notazione decimale, paragonabile al numero degli atomi dell’universo visibile (stimati essere nell’ordine dei 10^80^).

La chiave pubblica è calcolata a partire dalla chiave privata utilizzando la moltiplicazione su curve ellittiche, che è irreversibile: K = k * G, dove k è la chiave privata e, G è una costante chiamata _punto generatore_ e K è la chiave pubblica risultante. L’operazione inversa, conosciuta come _problema dei logaritmi finiti_ (calcolare k conoscendo K), è difficile tanto quanto provare tutti i possibili valori di k. Questo strumento matematico è la base per firme digitali sicure e non soggette a contraffazione che provino la proprietà dei fondi in bitcoin.

Un indirizzo bitcoin è una stringa di numeri e lettere che può essere condivisa con chiunque voglia inviarci del denaro; è quanto comunemente appare in una transazione come destinatario dei fondi. Esso viene ricavato dalla chiave pubblica attraverso un “algoritmo di hash” non invertibile che produce un’impronta digitale o “hash” di un input di qualsiasi dimensione. Quindi *un indirizzo bitcoin non coincide con una chiave pubblica*.

Lo scopo delle firme digitali è simile a quello delle firme scritte a mano: garantiscono che un messaggio sia stato generato da chi lo firma, non possono essere alterate e chi le utilizza non può negare di averlo fatto. Il protocollo di _firma digitale_ si compone di due parti, un algoritmo a chiave pubblica, che fornisce l’algoritmo matematico asimmetrico sottostante, e uno schema di _firma digitale_ che propone un modo di  utilizzare questo algoritmo asimmetrico per arrivare ad una _firma digitale_ funzionante.
Come visto poco sopra, vi è una chiave privata corrispondente a ciascuna chiave pubblica e di conseguenza a ciascun indirizzo bitcoin. Le chiavi pubbliche possono essere interpretate come numeri di conti bancari, mentre le chiavi private come le firme che possono sbloccare i conti. Per spendere i bitcoin, la transazione che autorizza la spesa deve essere firmata con la chiave privata.
Un punto tecnico in merito alle firme digitali è che il messaggio potrebbe essere di lunghezza arbitraria e questo può essere un problema poiché gli algoritmi implementati dalla crittografia a chiave pubblica sono lenti. La soluzione è quella di prendere l’hash del messaggio e di firmare questo invece del messaggio originale. L’output di una funzione di hash è sempre della stessa (più corta) lunghezza, indipendentemente dalla grandezza dell’input.
Per firmare un messaggio deve essere generato un _nonce_, ovvero un _numero random effimero_ usato una sola volta per ciascuna chiave privata. E’ essenziale che questo nonce non sia più riutilizzato, altrimenti sarebbe come rendere nota la propria chiave privata e quindi buttare via i propri fondi bitcoin.

== Transazioni

Una transazione dice al network che il proprietario di alcuni bitcoin ha autorizzato il loro trasferimento ad un altro proprietario, il quale, a sua volta, potrà spenderli creando una nuova transazione che autorizzi un secondo trasferimento e così via in una catena di proprietà. I bitcoin pertanto esistono in quanto riportati sulla blockchain, dove non sono presenti i conti e i saldi di chi li possiede, ma solamente le transazioni che li  spostano da un proprietario ad un altro.

Una transazione può essere creata con ogni mezzo, anche offline, e può essere propagata al network anche attraverso un canale non sicuro; i nodi la validano prima di propagarla ulteriormente.
Ogni transazione è composta da una lista di input (_TxIn_), che sono come debiti nei confronti di un conto bitcoin, e di output (_TxOut_), i quali sono come crediti aggiunti ad un conto bitcoin. Ogni output contiene un importo e l’indirizzo al quale è destinato; solamente chi può accedere a quell’indirizzo è in grado di  disporre dei bitcoin ad esso corrispondenti. Ciascun input, invece, contiene un riferimento all’output precedente (in questo modo le transazioni sono tra loro legate ed è possibile ripercorre la storia di ciascuna moneta) e la _firma digitale_ che autorizza la spesa dei relativi _TxOut_; la firma deve essere fatta con la chiave privata associata alla chiave pubblica dalla quale è stato ricavato l’indirizzo Bitcoin. In questi termini, “spendere” dei bitcoin significa firmare una transazione che trasferisca valore da una transazione precedente ad nuovo proprietario identificato da un indirizzo bitcoin.

Fra tutte le possibili transazioni ve ne è una particolare, _coinbase transaction_, che non contiene nessun input, ma solamente un output rappresentante la “ricompensa” per il miner per primo è riuscito a validare tutte le transazioni di un blocco includendolo nella Blockchain.

Una transazione raggruppa più _TxIn_ e _TxOut_ con lo scopo di redistribuire i fondi dei primi verso i secondi. Gli input si riferiscono sempre ad output precedenti, i quali non devono essere già stati spesi precedentemente perché la transazione sia valida. Infatti uno dei controlli che vengono eseguiti prima di validare una transazione è proprio la verifica che gli output che si vogliono spendere non siano già stati spesi in precedenza, in modo da evitare quello che viene definito come _double spending_. Si intuisce inoltre facilmente come sia necessario che la somma degli importi dei _TxIn_ sia maggiore o uguale alla somma dei _TxOut_. La differenza tra i due importi rappresenta una _fee_ che verrà riscossa da chi per primo riuscirà ad includere la transazione nella blockchain.

Un output deve essere speso completamente; se l’importo degli output è maggiore dell’importo da spendere, viene generato un _change_, ovvero un output aggiuntivo che viene indirizzato a chi sta spendendo i _TxOut_ della transazione. Concretamente si tratta di qualcosa di analogo al resto che si riceve in un tradizionale acquisto con gli euro in moneta o banconota; l’indirizzo utilizzato non coincide con nessuno degli indirizzi da cui provengono gli output in modo da garantire una maggiore privacy.

Una transazione contiene al suo interno una variabile denominata _lock time_, inoltre ogni input è associato ad un _sequence number_. Una transazione è ritenuta definitiva quando viene raggiunto il suo _lock time_ oppure quando  i _sequence number_ di tutti i suoi input sono impostati sul massimo valore possibile (dipendente dalla piattaforma, i.e. 32 bit oppure 64 bit). Il _lock time_ originariamente permetteva di mandare una transazione che potesse essere sostituita in un secondo momento, esprimendo il numero di blocchi (se inferiore a 500000000) o la data in formato Unix (se superiore a 500000000) prima del quale la transazione non poteva ritenersi definitiva. Perché una transazione possa essere sostituita almeno uno dei suoi input deve avere _sequence number_ inferiore al massimo. Versioni successive della transazione possono essere trasmesse con valori dei _sequence number_ più elevati. In questo modo una transazione può essere modificata dalle parti coinvolte prima di essere pubblicata sulla blockchain. Transazioni per le quali non è ancora stato raggiunto il _lock time_ oppure i cui _sequence number_ non sono impostati sul massimo valore possibile vengono definite _unfinalised transaction_s e non vengono incluse nella blockchain, ma scartate dai nodi che le ricevono.

Una volta che una transazione viene inviata al network, il primo nodo che la riceve verifica che sia valida, in caso affermativo, il nodo la propaga al resto della rete. Per verificare che una transazione sia valida, un nodo segue i tre step seguenti:

* Verifica che sia definitiva (non bloccata da _lock time_ e avente tutti i _sequence number_ valorizzati al massimo).
* Controlla che esistano gli output precedenti a cui gli input della transazione fanno riferimento e che non siano ancora stati spesi. I nodi conducono tale verifica consultando l’insieme degli output non ancora spesi presenti delle transazioni presenti sulla blockchain (_UTXO set_).
* Verifica che la somma dei valori in input sia maggiore di quelli in output; la differenza tra i due importi viene considerata come _fee_ lasciata al miner e viene inclusa nella _coinbase transaction_.
* Controlla che le firme di ciascun input siano valide, ovvero che ogni input  sia firmato con la chiave privata corrispondente alla chiave pubblica associata all’indirizzo a cui si riferisce.

Il software Bitcoin mantiene l’insieme di tutti gli output non ancora spesi (_UTXO set_), in modo che sia facile verificare la validità di una transazione, in quanto tale struttura occupa molto meno spazio dell’intera blockchain e può essere gestita dalla RAM. *Si può quindi affermare che i bitcoin in circolazione siano gli output non spesi delle transazioni presenti sulla blockchain*. Inoltre, essendo ciascun _UTXO_ nella blockchain è inalterabile e non può essere speso a meno che venga presentato un _TxIn_ che soddisfi le condizioni richieste, rimuovendolo così dall’_UTXO set_.

Finora abbiamo assunto che gli output siano inviati ad un indirizzo Bitcoin, in realtà il protoccollo è molto più flessibile: ogni _TxOut_ contiene un puzzle matematico che deve essere risolto per poter spendere l’importo in bitcoin associato. Il puzzle per sbloccare i fondi e la realtiva soluzione sono rappresentati da due script. Il primo è quello che crea il puzzle e viene denominato < _scriptPubKey_ > poiché nella sua versione più semplice contiene la chiave pubblica; il secondo, che sblocca i fondi, è chiamato < _scriptSig_ > in quanto contiene la firma associata all’indirizzo al quale sono stati inviati i bitcoin ed è contenuto all’interno dei _TxIn_.

== Consenso distribuito e Proof Of Work

Il vero grande successo del protocollo *Bitcoin* è quello di aver dato vita ad un sistema elettronico di pagamenti *peer-to-peer*, sicuro e affidabile, che non richiede fiducia in una Autority centrale, ma fondato su un algoritmo di consenso distribuito. Questo traguardo è stato possibile grazie alla *Blockchain*, un registro pubblico, distribuito e inalterabile, contenente la storia di tutte le transazioni.

Un sistema centralizzato sarebbe infatti esposto a diversi rischi. La presenza di un unico agente alla base dell'intero ecosistema comporta una fragilità intrinseca, il cosiddetto *Single Point of Failure*: l'ente centrale ha il potere di alterare o censurare i dati presenti nel registro.

I rischi derivanti da questo accentramento possono essere superati solo attraverso una ridistribuzione del potere dell'Autority. Tuttavia in questo contesto sorge una ulteriore difficoltà: ogni individuo che partecipa alla rete ha la possibilità di scrivere all'interno del registro. Come è possibile garantire che tale registro sia univoco e accettato da tutti? Tale criticità può essere ricondotta a quella formalizzata per la prima volta da Marshall Pease, Robert Shostak e Leslie Lamport nel 1982 e nota con il nome di *"Problema dei Generali Bizantini"*.

Nel loro articolo, link:http://research.microsoft.com/en-us/um/people/lamport/pubs/byz.pdf[*The Bizantine Generals Problem*], gli autori immaginano una situazione in cui diversi generali di un esercito devono decidere la strategia di attacco potendo comunicare tra di loro solo attraverso dei messaggeri. Tra di essi potrebbero esserci dei traditori. Per la buona riuscita dell'attacco è necessario che i generali si accordino su un univoco piano di azione e che un numero esiguo di traditori non possa alterarne il risultato.

L'analogia con la rete *peer-to-peer* utilizzata nel protocollo Bitcoin risiede proprio nella necessità di trovare un consenso univoco sulle transazioni da scrivere nella Blockchain, impedendo ai nodi che agiscono in modo scorretto di alterare la storia delle transazioni.

La proposta di Satoshi Nakamoto risolve questo problema attraverso l'utilizzo di incentivi di natura economica: rendite di signoraggio sono garantite a chi scrive transazioni nel registro condiviso, ovvero colui che dimostra di aver bruciato più risorse al di fuori della rete per risolvere un problema di natura crittografica. Questa procedura è nota con il nome di *proof of work (PoW)*.

colui che valida il blocco e colui che ha bruciato più risorse.

il lavoro non è "inutile" perchè viene usato per dare sicurezza alla rete. I costi di una moneta tradizionale sono molto più elevati.

== Mining
